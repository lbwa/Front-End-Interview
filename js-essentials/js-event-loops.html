<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Front End Interview | 事件循环 event loop</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/front-end-interview/assets/css/30.styles.fd504cf3.css" as="style"><link rel="preload" href="/front-end-interview/assets/js/app.db72fc95.js" as="script"><link rel="preload" href="/front-end-interview/assets/js/16.21fc58fd.js" as="script"><link rel="prefetch" href="/front-end-interview/assets/js/12.3c29124f.js"><link rel="prefetch" href="/front-end-interview/assets/js/0.bf775a11.js"><link rel="prefetch" href="/front-end-interview/assets/js/1.1190d708.js"><link rel="prefetch" href="/front-end-interview/assets/js/2.5de7ca40.js"><link rel="prefetch" href="/front-end-interview/assets/js/3.f70d72bc.js"><link rel="prefetch" href="/front-end-interview/assets/js/4.a541e70b.js"><link rel="prefetch" href="/front-end-interview/assets/js/5.5c894db1.js"><link rel="prefetch" href="/front-end-interview/assets/js/6.98ce2f58.js"><link rel="prefetch" href="/front-end-interview/assets/js/7.c976c70d.js"><link rel="prefetch" href="/front-end-interview/assets/js/8.69b104a6.js"><link rel="prefetch" href="/front-end-interview/assets/js/9.082b8ac0.js"><link rel="prefetch" href="/front-end-interview/assets/js/10.a347006c.js"><link rel="prefetch" href="/front-end-interview/assets/js/11.4f688f0a.js"><link rel="prefetch" href="/front-end-interview/assets/js/13.66c864b0.js"><link rel="prefetch" href="/front-end-interview/assets/js/14.13130231.js"><link rel="prefetch" href="/front-end-interview/assets/js/15.dcc3d7af.js"><link rel="prefetch" href="/front-end-interview/assets/js/17.2b64bdc6.js"><link rel="prefetch" href="/front-end-interview/assets/js/18.d801340d.js"><link rel="prefetch" href="/front-end-interview/assets/js/19.5a161372.js"><link rel="prefetch" href="/front-end-interview/assets/js/20.ee552e08.js"><link rel="prefetch" href="/front-end-interview/assets/js/21.8031b3ff.js"><link rel="prefetch" href="/front-end-interview/assets/js/22.8ffcc061.js"><link rel="prefetch" href="/front-end-interview/assets/js/23.86599a03.js"><link rel="prefetch" href="/front-end-interview/assets/js/24.139449ee.js"><link rel="prefetch" href="/front-end-interview/assets/js/25.3345fd47.js"><link rel="prefetch" href="/front-end-interview/assets/js/26.a505ed06.js"><link rel="prefetch" href="/front-end-interview/assets/js/27.58a5efca.js"><link rel="prefetch" href="/front-end-interview/assets/js/28.78d7c9b3.js"><link rel="prefetch" href="/front-end-interview/assets/js/29.b53cf265.js">
    <link rel="stylesheet" href="/front-end-interview/assets/css/30.styles.fd504cf3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/front-end-interview/" class="home-link router-link-active"><!----><span class="site-name">
      Front End Interview
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-interview/" class="nav-link">主页</a></div><div class="nav-item"><a href="/front-end-interview/SUMMARY.html" class="nav-link">目录</a></div><a href="https://github.com/lbwa/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-interview/" class="nav-link">主页</a></div><div class="nav-item"><a href="/front-end-interview/SUMMARY.html" class="nav-link">目录</a></div><a href="https://github.com/lbwa/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>基础</span><!----></p><ul class="sidebar-group-items"><li><a href="/front-end-interview/js-essentials/js-variable.html" class="sidebar-link">变量</a></li><li><a href="/front-end-interview/js-essentials/js-hoisting.html" class="sidebar-link">变量提升</a></li><li><a href="/front-end-interview/js-essentials/js-lexical-environments.html" class="sidebar-link">作用域</a></li><li><a href="/front-end-interview/js-essentials/js-prototype.html" class="sidebar-link">原型和原型链</a></li><li><a href="/front-end-interview/js-essentials/js-prototype-application.html" class="sidebar-link">原型的实际应用</a></li><li><a href="/front-end-interview/js-essentials/js-object-this.html" class="sidebar-link">函数 this 对象</a></li><li><a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html" class="sidebar-link">执行上下文</a></li><li><a href="/front-end-interview/js-essentials/js-async.html" class="sidebar-link">异步执行</a></li><li><a href="/front-end-interview/js-essentials/js-event-loops.html" class="active sidebar-link">事件循环 event loop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-interview/js-essentials/js-event-loops.html#事件循环定义" class="sidebar-link">事件循环定义</a></li><li class="sidebar-sub-header"><a href="/front-end-interview/js-essentials/js-event-loops.html#任务源" class="sidebar-link">任务源</a></li><li class="sidebar-sub-header"><a href="/front-end-interview/js-essentials/js-event-loops.html#任务队列-task-queue" class="sidebar-link">任务队列 task queue</a></li><li class="sidebar-sub-header"><a href="/front-end-interview/js-essentials/js-event-loops.html#事件循环拓展应用-——-异步操作" class="sidebar-link">事件循环拓展应用 —— 异步操作</a></li></ul></li><li><a href="/front-end-interview/js-essentials/js-promise.html" class="sidebar-link">Promise 对象</a></li><li><a href="/front-end-interview/js-essentials/js-async-function.html" class="sidebar-link">async 函数</a></li><li><a href="/front-end-interview/js-essentials/js-modules.html" class="sidebar-link">模块化</a></li><li><a href="/front-end-interview/js-essentials/js-class.html" class="sidebar-link">类</a></li><li><a href="/front-end-interview/js-essentials/js-common-functions.html" class="sidebar-link">ES6+ 一些常用功能</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="事件循环-event-loop"><a href="#事件循环-event-loop" aria-hidden="true" class="header-anchor">#</a> 事件循环 event loop</h1><p>（本节为 <a href="https://lbwa.github.io/2018/03/08/Event-loop/" target="_blank" rel="noopener noreferrer">我的博客 —— 理解 event loop 机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的重新归纳。）</p><p>单线程的实现方式就是事件循环（<code>event loop</code>）。</p><p>存在两种 <code>event loops</code>（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loop" target="_blank" rel="noopener noreferrer">W3C<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），即一种在 <code>browsing context</code> 下的事件循环，一种是在 <code>web workers</code> 下的循环。本文讨论在 <code>browsing context</code> 下的事件循环。</p><h2 id="事件循环定义"><a href="#事件循环定义" aria-hidden="true" class="header-anchor">#</a> 事件循环定义</h2><p>依据标准中对进程模型的流程描述（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener noreferrer">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）可得出，在完成一个宏任务，并清空因宏任务产生的微任务队列时，称之为一个事件循环。</p><h2 id="任务源"><a href="#任务源" aria-hidden="true" class="header-anchor">#</a> 任务源</h2><ul><li><p>宏任务（macrotask）：</p><ol><li><p>script</p><ul><li><p>整体代码（<a href="https://www.ecma-international.org/ecma-262/#script-record" target="_blank" rel="noopener noreferrer">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），即代码执行的基准执行上下文（<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">章节 —— 执行上下文</a>）</p></li><li><p>该宏任务的目的在于，将整体代码段（或理解为模块）推入执行上下文栈（<code>execution context stack</code>）中。</p><ul><li><p>执行上下文栈初始会设置 <code>script</code> 为 <code>当前正在运行执行上下文</code>（<code>running execution context</code>），这期间可能因执行而创建新的执行上下文，那么就会依据模块内的代码不断的设置 <strong>当前正在运行执行上下文</strong>（<code>running execution context</code>），这样模块内的代码就会依次得以执行（此处主要是章节 —— <a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">执行上下文</a> 中 <code>Running execution context 的更替</code> 的实际应用）。</p></li><li><p>比如设置一些事件监听程序，一些声明，执行一些初始任务。在执行完成该任务时，会建立词法作用域等一系列相关运行参数。</p></li></ul></li></ul></li><li><p>setTimeout，setInterval，setImmediate（服务端 API）</p></li><li><p>I/O</p><ul><li><p>可拓展至 Web API（<a href="https://www.w3.org/TR/html5/webappapis.html#generic-task-sources" target="_blank" rel="noopener noreferrer">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><ol><li><p>DOM 操作</p></li><li><p>网络任务</p><ul><li>Ajax 请求</li></ul></li><li><p>history traversal</p><ul><li>history.back()</li></ul></li><li><p>用户交互</p><ul><li><p>其中包括常见 DOM2（<code>addEventListener</code>）和 DOM0（<code>onHandle</code>）级<strong>事件监听回调函数</strong>。如 <code>click</code> 事件回调函数等。</p></li><li><p>特别地，事件需要冒泡到 <code>document</code> 对象之后并且事件回调执行<strong>完成后</strong>，才算该宏任务执行完成。否则一直存在于执行上下文栈中，等待事件冒泡并事件回调完成（来源：Jake Archibald blog - <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">level 1 boss fight<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p></li></ul></li></ol></li></ul></li></ol><ul><li><strong>UI rendering</strong></li></ul></li><li><p>微任务（microtask）:</p><ol><li><p>process.nextTick（<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" target="_blank" rel="noopener noreferrer">Node.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p></li><li><p>Promise 原型方法（即 <code>then</code>、<code>catch</code>、<code>finally</code>）中被调用的回调函数</p></li><li><p>MutationObserver（<a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" target="_blank" rel="noopener noreferrer">DOM Standard<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><ul><li>用于监听节点是否发生变化</li></ul></li><li><p>Object.observe(已废弃)</p></li></ol></li><li><p><strong>特别注明</strong>：在 <code>ECMAScript</code> 中称 <code>microtask</code> 为 <code>jobs</code>（<a href="http://www.ecma-international.org/ecma-262/#sec-performpromisethen" target="_blank" rel="noopener noreferrer">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其中 <a href="http://www.ecma-international.org/ecma-262/#sec-enqueuejob" target="_blank" rel="noopener noreferrer">EnqueueJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 即指添加一个 <code>microtask</code>）。</p></li></ul><p><code>macrotask</code> 和 <code>microtask</code> 中的每一项都称之为一个 <strong>任务源</strong>。</p><p>以上分类中，每一项执行时均占用<code>当前正在运行执行上下文</code>（<code>running execution context</code>）（线程）。如，可理解为浏览器渲染线程与 JS 执行共用一个线程。</p><p><strong>依据标准拓展</strong>：</p><ul><li><p>在 <code>W3C</code> 或 <code>WHATWG</code> 中除非特别指明，否则 <code>task</code> 即是指 <code>macrotask</code>。</p></li><li><p>根据 <code>W3C</code>（<a href="https://www.w3.org/TR/html5/webappapis.html#microtask" target="_blank" rel="noopener noreferrer">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）关于 <code>microtask</code> 的描述，只有两种微任务类型：单独的回调函数微任务（solitary callback microtasks），复合微任务（compound microtasks）。那么即在 <code>W3C</code> 规范中<strong>所有</strong>的<strong>单独的回调函数</strong>都是<strong>微任务</strong>类型。</p><ul><li><p>solitary callback：Promise 原型的原型方法，即 <code>then</code>、<code>catch</code>、<code>finally</code> 能够调用单独的回调函数的方法。</p></li><li><p>compound microtask：</p><ol><li><p>MutationObserver（<a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" target="_blank" rel="noopener noreferrer">DOM Standard - 4.3.2 步骤 5<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p></li><li><p>process.nextTick（Only for <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" target="_blank" rel="noopener noreferrer">Node.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><ul><li><blockquote><p>all callbacks passed to process.nextTick() will be resolved before the event loop continues.</p></blockquote></li></ul></li></ol></li></ul></li><li><p>特别指明，<code>Web API</code> （event loops 章节在标准中是属于 Web API 大类）是属于宏任务类型，如 <code>Ajax</code> 属于 <code>I/O</code>（来源：<a href="https://www.w3.org/TR/html5/webappapis.html#task-queues" target="_blank" rel="noopener noreferrer">using a resource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），但 <code>Ajax</code> 调用的 <code>Promise</code> 类型回调函数都是微任务类型。</p></li></ul><h2 id="任务队列-task-queue"><a href="#任务队列-task-queue" aria-hidden="true" class="header-anchor">#</a> 任务队列 task queue</h2><p>任务队列分为 <code>宏任务队列</code> 和 <code>微任务队列</code>。一个事件循环中可能有一个或多个任务队列。因为在执行一个宏任务时，可能产生微任务调用，即产生新的微任务队列。</p><p><strong>相同类型</strong>的任务源的任务被调用时进入相同的任务队列，反之进入不同的任务队列。</p><h3 id="标准（w3c-and-whatwg）中的队列模型"><a href="#标准（w3c-and-whatwg）中的队列模型" aria-hidden="true" class="header-anchor">#</a> 标准（W3C and WHATWG）中的队列模型</h3><p><strong>注</strong>：</p><ul><li><p>依据标准<a href="https://www.w3.org/TR/html5/webappapis.html#microtask" target="_blank" rel="noopener noreferrer">描述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，除非特别指明是 <code>microtask queue</code>，那么我们一般常说的任务队列（<code>task queue</code>）都是指 <code>宏任务队列</code>（<code>macrotask queue</code>）。</p></li><li><p>每个事件循环都有一个 <code>当前执行中的任务</code>（<code>currently running task</code>），用于轮询队列中的任务（<code>handle reentrancy</code>）。</p></li><li><p>每个事件循环都有一个 <code>已执行 microtask 检查点标志</code>（<code>performing a microtask checkpoint flag</code>）（初始值一定为 false）表示已经执行了 <code>microtask</code> 检查点，用于阻止执行 <code>microtask checkpoint</code> 算法的可重入调用。</p><ol><li><p>可重入调用（<a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)" target="_blank" rel="noopener noreferrer">reentrant invocation<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）是指，算法在执行过程中意外中断时，在当前调用未完成的情况下被再次从头开始执行。一旦可重入执行完成，上一次被中断的调用将会恢复执行。</p></li><li><p>设置该检查点的原因是：</p><ul><li>执行微任务时，可能会调用其他回调函数，当其他回调函数时，并在弹出执行上下文栈时，会断言当前执行上下文栈是否为空，若为空时，那么就会再一次执行 <code>microtask checkpoint</code>（来源：<a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener noreferrer">perform a microtask checkpoint - step 2.3<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script" target="_blank" rel="noopener noreferrer">clean up after running script<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），若没有设置检查点执行标志的话就会再次进入 <code>microtask queue</code> 重复执行 <code>microtask</code>。</li></ul></li></ol></li></ul><p>（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener noreferrer">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><ol><li><p>在 <code>browsing context</code> 事件循环的情况下（与第 8 步并列），选择当前 <code>task queue</code> 中<strong>最早</strong>加入的 task。如果没有任务被选中（即当前 <code>task queue</code> 为空），那么直接跳转到第 6 步 <code>Microtasks</code></p><ul><li>如 <code>Ajax</code> 请求返回数据时，若当前 <code>task queue</code> 为空时，将直接跳转执行回调函数微任务。</li></ul></li><li><p>设置当前事件循环的 <code>当前执行中的任务</code> 为第 1 步被选出的 task。</p></li><li><p><code>Run</code>：执行当前被选出的 task（即 task 进入最上层<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">执行上下文栈</a><code>execution context stack</code>）。</p></li><li><p>重置当前事件循环的 <code>当前执行中的任务</code> 为默认值 null。</p></li><li><p>从当前的 <code>task queue</code> 中移除在第 3 步执行过的任务。</p></li><li><p><code>Microtasks</code>：执行 <code>microtask</code> 检查点。</p><ul><li><p>当 <code>已执行 microtask 检查点标志</code> 为 false 时：</p><ol><li><p>设置 <code>已执行 microtask 检查点标志</code> 为 true。</p></li><li><p><code>操作（handling) microtask 队列</code>：在当前 <code>microtask queue</code> 为空时，跳转到步骤 <code>Done</code> 之后。</p></li><li><p>选中 <code>microtask queue</code> 中最早加入的 <code>microtask</code>。</p></li><li><p>设置当前事件循环的 <code>当前执行中的任务</code> 值为上一步选中的 <code>microtask</code>。</p></li><li><p><code>Run</code>：执行选中的 <code>microtask</code>（进入最上层<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">执行上下文栈</a>（来源1：<a href="https://html.spec.whatwg.org/#enqueuejob(queuename,-job,-arguments):queue-a-microtask" target="_blank" rel="noopener noreferrer">HTML Standard EnqueueJob 7.6<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、来源2：<a href="http://www.ecma-international.org/ecma-262/#sec-enqueuejob" target="_blank" rel="noopener noreferrer">ECMAScript EnqueueJob 步骤4<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>））。</p></li><li><p>重置置当前事件循环的 <code>当前执行中的任务</code> 值为 null。</p></li><li><p>从 <code>microtask queue</code> 中移除第 5 步 <code>Run</code> 被执行的 <code>microtask</code>，回到第 3 步 <code>操作（handling) microtask 队列</code>。</p><ul><li><strong>重点</strong>：为在一个事件循环中，总是要<strong>清空</strong>当前事件循环中的微任务队列<strong>才会进行重渲染</strong>（<code>Vue.js</code> 的 DOM 更新原理）。</li></ul></li><li><p><code>Done</code>：对于每一个 <code>responsible event loop</code> 是当前事件循环的环境设置对象（<code>environment setting object</code>），向它（环境设置对象）告知关于 <code>rejected</code> 状态的 <code>Promise</code> 对象的信息。</p><ul><li><p>个人理解为触发浏览器 <code>uncaught</code> 事件，并抛出 <code>unhandled promise rejections</code> 错误（<a href="https://www.w3.org/TR/html5/webappapis.html#notify-about-rejected-promises" target="_blank" rel="noopener noreferrer">W3C<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p></li><li><p>此步骤主要是向开发者告知存在未被捕获的 <code>rejected</code> 状态的 <code>Promise</code>。</p></li></ul></li><li><p>执行并清空 <code>Indexed Database</code>（用于本地存储数据的 API） 的修改请求。</p></li><li><p>重置 <code>已执行 microtask 检查点标志</code> 为 false。</p></li></ol></li><li><p>当一个复合微任务（<code>compound microtask</code>）执行时，客户端必须去执行一系列的复合微任务的<code>子任务</code>（subtask）</p><ol><li><p>设置 parent 为当前事件循环的 <code>当前执行中的任务</code>。</p></li><li><p>设置 <code>子任务</code> 为一个由一系列给定步骤组成的新 microtask。</p></li><li><p>设置 <code>当前执行中的任务</code> 为 <code>子任务</code>。这种微任务的任务源是微任务类型的任务源。这是一个复合微任务的 <code>子任务</code>。</p></li><li><p>执行 <code>子任务</code>（进入<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">执行上下文栈</a>）。</p></li><li><p>重置当前事件循环的 <code>当前执行中的任务</code> 为 parent。</p></li></ol></li></ul></li><li><p>更新 DOM 渲染。</p><ul><li>一个宏任务 task <strong>至此</strong>整体执行结束（包含调用，执行，重渲染），也是一个<strong>事件循环结束</strong>。</li></ul></li><li><p>（与第 1 步并列）如果当前的事件循环是 <code>web works</code> 的事件循环，并且在当前事件循环中的 <code>task queue</code> 为空，并且 <code>WorkerGlobalScope</code> 对象的 <code>closing</code> 为 true，那么将摧毁当前事件循环，并取消以上的事件循环步骤，并恢复执行一个 <code>web worker</code> 的步骤。</p></li><li><p>回到第 1 步执行下一个事件循环。</p></li></ol><h3 id="示例"><a href="#示例" aria-hidden="true" class="header-anchor">#</a> 示例</h3><p>以一个示例讲解事件循环：</p><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// script</span>
<span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from script beginning'</span><span class="token punctuation">)</span>

<span class="token comment">// 2</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 该匿名函数称为匿名函数a</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>

<span class="token comment">// 3</span>
<span class="token keyword">const</span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from internal part'</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 4</span>
ins<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from 1st ins.then()'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from 2nd ins.then()'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from script bottom'</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>以上整个代码段即是，<code>macro-task</code> 中的 <code>script</code> 任务源。</p><p>执行原理（依据 Chrome 66 的 V8 实现）如下：</p><ol><li><p>整个代码段 <code>script</code> 进入执行上下文栈（亦称调用栈，<code>call stack</code>（<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">来源</a>）），执行 1 处代码调用 <code>console.log</code> 函数，该函数进入调用栈，之前 <code>script</code> 执行上下文执行暂停（冻结），转交执行权给 <code>console.log</code>。<code>console.log</code>成为<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">当前执行中的执行上下文</a>（<code>running execution context</code>）。<code>console.log</code> 执行完成立即弹出调用栈，<code>script</code> 恢复执行。</p></li><li><p><code>setTimeout</code> 是一个任务分发器，该函数本身会立即执行，延迟执行的是其中传入的参数（匿名函数 a）。<code>script</code> 暂停执行，内部建立一个 1 秒计时器。<code>script</code> 恢复执行接下来的代码。1 秒后，再将匿名函数 a 插入宏任务队列（根据宏任务队列是否有之前加入的宏任务，可能不会立即执行）。</p></li><li><p>声明恒定变量 <code>ins</code>，并初始化为 <code>Promise</code> 实例。特别地，<code>Promise</code> 内部代码会在本轮事件循环立即执行。那么此时， <code>script</code> 冻结，开始执行 <code>console.log</code>，<code>console.log</code> 弹出调用栈后，<code>resolve()</code> 进入调用栈，将 <code>Promise</code> 状态 <code>resolved</code>，并之后弹出调用栈，此时恢复 script 执行。</p></li><li><p>因为第 3 步，已经在本轮宏任务完成前 <code>resolved</code> ，否则，将跳过第 4 步向本轮事件循环的微任务队列添加回调函数（<a href="/front-end-interview/js-essentials/js-promise.html">来源</a>）。调用 <code>ins</code> 的 <code>then</code> 方法，将第一个 <code>then</code> 中回调添加到 <code>微任务队列</code>，继续执行，将第二个 <code>then</code> 中回调添加到 <code>微任务队列</code>。</p></li><li><p>如同 1 时的执行原理。</p></li><li><p><code>script</code> 宏任务执行完成，弹出执行上下文栈。此时，微任务队列中有两个 <code>then</code> 加入的回调函数等待执行。另外，若距 2 超过 1 秒钟，那么宏任务队列中有一个匿名函数 a 等待执行，否则，此时宏任务队列为空。</p></li><li><p>在当前宏任务执行完成并弹出调用栈后，开始<strong>清空</strong>因宏任务执行而产生的微任务队列。首先执行 <code>console.log('I am from 1st ins.then()')</code>，之后执行 <code>console.log('I am from 2nd ins.then()')</code>。</p></li><li><p>微任务队列清空后，开始调用下一宏任务（即进入下一个事件循环）或等待下一宏任务加入任务队列。此时，在 2 中计时 1 秒后，加入匿名函数 a 至宏任务队列，此时，因之前宏任务 script 执行完成而清空，那么将匿名函数 a 加入调用栈执行，输出 <code>I am from setTimeout</code>。</p></li></ol><p><strong>注</strong>：<code>JavaScript</code> 中在某一函数内部调用另一函数时，会暂停（冻结）当前函数的执行，并将当前函数的执行权转移给新的被调用的函数（具体解析见<a href="/front-end-interview/js-essentials/js-execution-context/js-execution-context.html">章节 - 执行上下文</a>）。</p><p>示例总结：</p><ol><li><p><strong>在一个代码段（或理解为一个模块）中</strong>，所有的代码都是基于一个 <code>script</code> 宏任务进行的。</p></li><li><p>在当前宏任务执行完成后，<strong>必须</strong>要清空因执行宏任务而产生的<code>微任务队列</code>。</p></li><li><p>只有当前微任务队列清空后，才会调用下一个宏任务队列中的任务。即进入下一个事件循环。</p></li><li><p><code>new Promise</code> 时，<code>Promise</code> 参数中的匿名函数是<strong>立即执行</strong>的。被添加进<code>微任务队列</code>的是 <code>then</code> 中的回调函数。</p><ul><li><strong>特别地</strong>，只有 <code>Promise</code> 中的状态为 <code>resolved</code> 或 <code>rejected</code> 后（<a href="https://promisesaplus.com/#point-26" target="_blank" rel="noopener noreferrer">Promise 标准<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），才会调用 <code>Promise</code> 的原型方法（即 <a href="https://promisesaplus.com/#point-26" target="_blank" rel="noopener noreferrer">then<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<code>catch</code>（因为是 <code>then</code> 的<a href="https://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch" target="_blank" rel="noopener noreferrer">语法糖<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所以与 <code>then</code> 同理）、<code>finally</code>（<code>onfinally</code>时<a href="https://tc39.github.io/ecma262/#sec-promise.prototype.finally" target="_blank" rel="noopener noreferrer">触发<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）），才会将回调函数到添加微任务队列中。</li></ul></li><li><p><code>setTimeout</code> 是作为任务分发器的存在，他自身执行会创建一个计时器，只有待计时器结束后，才会将 <code>setTimeout</code> 中的第一参数函数添加至<code>宏任务队列</code>。换一种方式理解，<code>setTimeout</code> 中的函数<strong>一定不是在当前事件循环</strong>中被调用。</p></li></ol><p>以下是在客户端（Node.js 可能有不同结果）的输入结果：</p><div class="language-bash line-numbers-mode"><pre class="language-bash"><code>I am from script beginning
I am from internal part
I am from script bottom
I am from 1st ins.then<span class="token punctuation">(</span><span class="token punctuation">)</span>
I am from 2nd ins.then<span class="token punctuation">(</span><span class="token punctuation">)</span>
I am from setTimeout
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="事件循环拓展应用-——-异步操作"><a href="#事件循环拓展应用-——-异步操作" aria-hidden="true" class="header-anchor">#</a> 事件循环拓展应用 —— 异步操作</h2><ol><li><p>定时任务：setTimeout，setInterval</p></li><li><p>请求数据：Ajax 请求，图片加载</p></li><li><p>事件绑定</p></li></ol><p>一般地，在 JS 开发过程中，凡是可能造成代码阻塞的地方都可根据实际情况考虑使用异步操作。比如，数据获取等等。</p></div><div class="content edit-link"><!----><div class="last-updated"><span class="prefix">Last Updated: </span><span class="time">6/16/2018, 5:46:28 PM</span></div></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/front-end-interview/js-essentials/js-async.html" class="prev">
          异步执行
        </a></span><span class="next"><a href="/front-end-interview/js-essentials/js-promise.html">
          Promise 对象
        </a> →
      </span></p></div></div></div></div>
    <script src="/front-end-interview/assets/js/16.21fc58fd.js" defer></script><script src="/front-end-interview/assets/js/app.db72fc95.js" defer></script>
  </body>
</html>
